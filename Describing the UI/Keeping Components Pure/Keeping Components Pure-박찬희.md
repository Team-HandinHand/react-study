# Keeping Components Pure

순수 함수는 오직 연산만을 수행합니다. 컴포넌트를 엄격하게 순수 함수로 작성하면 코드 베이스는 점점 커지더라도 버그를 피할 수 있습니다.

## 순수성: 공식으로서의 컴포넌트
컴퓨터 과학에서의 순수 함수의 특징
- 자신의 일에 집중. 함수가 호출되기 전 존재했던 어떤 객체나 변수는 변경하지 않음
- 같은 입력, 같은 출력 같은 입력이 주어지면 같은 결과 반환
```js
function double(number) {
  return 2 * number;
}
```
위 예시 `double`은 순수 함수로 `3`을 넘기면 항상 `6`을 반환합니다.

React는 작성되는 모든 컴포넌트가 순수 함수일 것이라 가정합니다. 이는 작성되는 React 컴포넌트에 같은 입력이 주어지면 반드시 같은 JSX를 반환하는 것을 의미합니다.

## 사이드 이펙트: 의도하지(않은) 결과
순수 함수는 계산만 수행하며 그 이상은 수행하지 않습니다. 구성 요소를 순수 함수로만 작성하면 코드 베이스가 커짐에 따라 당황스러운 버그와 예측할 수 없는 동작을 방지할 수 있습니다. 이런 이점을 얻기 위해선 몇가지 규칙을 지켜야 합니다.
```jsx
let guest = 0;

function Cup() {
  // 나쁜 지점: 이미 존재했던 변수를 변경하고 있다!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```
이 컴포넌트는 바깥에서 선언된 `guest`라는 변수를 읽고 수정하고 있습니다. 이는 어느 상황에서 랜더링 되느냐에 따라 다른 JSX를 생성합니다. 즉 순수 함수가 아닙니다.

이를 수정하여 변수를 프로퍼티로 넘겨 고칠 수 있습니다.
```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```
> 이러한 규칙을 위반하는 것을 방지하기 위해 엄격 모드로 감지할 수 있습니다.<br>
엄격 모드는 각 컴포넌트의 함수를 두 번 호출하여 규칙을 위반하는 컴포넌트를 찾는데 도움을 줍니다.<br>
**엄격모드 사용 방법** <br>
최상단 컴포넌트를 `<React.StrictMode>`로 감싸기

## 지역 변형: 컴포넌트의 작은 비밀
순수 함수는 함수 스코프 밖의 변수나 호출 전에 생성된 객체를 변경하지 않습니다. 그러나, 랜더링 하는 동안 만든 변수와 객체를 견병하는 것은 문제가 없습니다.

아래 예시는 배열을 만들고, `cups` 변수에 할당하고, 컵 한 묶음을 `push` 합니다.
```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```
만약 `cups` 변수나 배열이 `TeaGathering`의 바깥에서 생성되었다면 문제가 되지만 `TeaGathering` 안 동일한 랜더링 중에 생성되었기 때문에 괜찮습니다. 이 현상을 **지역 변형**이라 합니다.

## 부작용을 일으킬 수 있는 지점

함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가, 어딘가에서 무언가가 바뀌어야 합니다. 이러한 화면을 업데이트하고, 애니메이션을 시작하고, 데이터 변경하는 것을 **사이드 이펙트** 라고 합니다. 랜더링 중 발생하는 것이 아닌 사이드에서 발생하는 현상입니다.

React에서 말하는 사이드 이펙트는 보통 이벤트 핸들러에 포함됩니다.
이벤트 핸들러는 컴포넌트 내부에서 정의되었지만 랜더링 중에 실행 되지 않기 때문에 순수할 필요가 없습니다.

다른 옵션을 모두 사용했지만 사이드 이펙트에 적합한 이벤트 핸들러를 찾을 수 없는 경우에도, 컴포넌트에서 `useEffect` 호출을 사용하여 반환된 JSX에 해당 이벤트 핸들러를 연결할 수 있습니다. 이것은 React에게 사이드 이펙트가 허용될 때 렌더링 후 나중에 실행하도록 지시합니다. **그러나 이 접근 방식이 마지막 수단이 되어야 합니다.**
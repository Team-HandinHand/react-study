# Keeping Components Pure

자바스크립트 일부 함수는 *순수*합니다. 순수 함수는 오직 연산만을 수행합니다. 

컴포넌트를 엄격하게 순수함수로 작성하면 코드베이스가 점점 커지더라도 예상밖의 동작이나 당황케하는 버그를 피할 수 있습니다.

일부 JS 함수는 '순수'하다. 

순수 함수 
- 동일한 매개변수(입력)가 주어질 때 항상 동일한 결과를 반환하는 함수를 말한다. 
- 더 자세히 말하면 함수의 입력 외에 함수의 결과에 영향을 미치는 사이드 이펙트가 없는 함수로, 순수 함수로만 코드를 작성하면 의도하지 않은 동작이나 버그를 줄일 수 있기 때문에 JS에서는 이러한 순수함수를 만들기 위해 데이터 불변성을 유지하는 것이 중요하다.

순수함수는 다음과 같은 특징이 있다.

1. 동일 입력 동일 출력
2. 호출되기 전 존재했던 객체나 변수를 변경하지 않는다.

2번에 위배되는 코드로 아래 예시를 들 수 있다.

```jsx
let guest = 0;

function Cup() {
  // 나쁜 지점: 이미 존재했던 변수를 변경하고 있다!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}

```

위 코드는 함수 내부에서 guest라는 외부 변수를 변경하고 있다. 순수 함수는 오직 매개변수에 의해서만 결과가 결정되어야 하는데, 외부 변수 guest를 변경함에 따라 함수의 결과가 달라진다.

이를 아래와 같이 수정할 수 있다. guest를 prop을 전달한 것으로 수정한다.

> 이 컴포넌트는 컴포넌트 바깥에 선언된 `guest`라는 변수를 읽고 수정하고있다.
 이건 **컴포넌트가 여러번 불리면 다른 JSX를 생성한다는 것을 의미!** 그리고 더욱이 *다른* 컴포넌트 가 `guest`를 읽었다면 언제 렌더링 되었는지에 따라 그 컴포넌트 또한 다른 JSX를 생성할거다! 


```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}

```

이제 JSX가 반환되는 것은 오직 `guest` 프로퍼티에 의존하기 때문에 
컴포넌트는 순수하다.


## **StrictMode**

React에서는 렌더링하는 동안 읽을 수 있는 입력이 3가지 있다.

-  (props, state, context) 

이 입력들은 항상 읽기 전용으로 취급되어야 한다.


> 사용자 입력에 대한 응답으로 어떤 것을 변경하려면 변수 대신 state로 변경해야 한다.  
컴포넌트가 렌더링되는 동안 기존의 변수나 객체를 변경하면 안된다.

Strict Mode는 각 컴포넌트의 함수를 2번 호출함으로서 이런 규칙을 위반하는 컴포넌트를 찾아낸다.

## **지역 변이**

2번 특징을 위배한 경우를 '변이'라고 한다. 순수 함수는 함수 이전의 변수나 객체를 변이시키지 않는다. 하지만 렌더링하는 동안 방금 생성한 변수나 객체를 변경하는 것은 가능하다.

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}

```

let cups를 TeaGathering 함수의 외부에 선언하고, strict mode를 실행하면 콘솔에 에러가 발생한다.

React에서 사이드 이펙트는 보통 이벤트 핸들러에 속한다. 
> 이벤트 핸들러 : 유저가 어떤 동작을 수행할 때 React가 실행하는 함수
 이 역시 컴포넌트 내부에 정의되어 있지만 렌더링 중에는 실행되지 않는다.

만약 사이드 이펙트에 적합한 이벤트 핸들러를 찾을 수 없다면 useEffect 호출로 사용할 수 있다. 다만 이는 최후의 수단으로 사용해야 하며 가능한 렌더링으로 표현하는 것이 좋다.



### **부작용을 *일으킬 수 있는* 지점**

- 사이드 이펙트란?

    - 화면 업데이트, 애니메이션 시작, 데이터 변경 등 렌더링 외부에서 발생하는 변화.

    - 주로 이벤트 핸들러에 포함.
    - 이벤트 핸들러는 렌더링 중 실행되지 않으므로 순수할 필요 없음.

- useEffect 사용:

    - 이벤트 핸들러로 처리하기 어려운 사이드 이펙트는 useEffect로 처리.
    - 렌더링 후 실행되도록 React에 지시.
    - 최후의 수단으로 사용.

### **요약**

- 컴포넌트는 순수해야만 합니다. 이것은 두가지를 의미한다.
    - 렌더링전에 존재했던 객체나 변수를 변경하지 않아야 한다.
    - **같은 입력, 같은 결과물.** 입력이 같을 경우, 컴포넌트는 항상 같은 JSX를 반환해야 한다.

- 컴포넌트는 서로의 렌더링 순서에 의존하지 않아야 한다.
- 컴포넌트가 렌더링을 위해 사용되는 입력을 변형해서는 안된다.. 화면을 업데이트하려면 기존 객체를 변환하는 대신 상태를 “설정”해라 
